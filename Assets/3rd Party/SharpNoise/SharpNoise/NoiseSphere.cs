using System.Threading.Tasks;
using UnityEngine;
namespace SharpNoise
{
    /// <summary>
    /// Implements a noise map, a 2-dimensional array of floating-point
    /// values.
    /// </summary>
    /// <remarks>
    /// A noise map is designed to store coherent-noise values generated by a
    /// noise module, although it can store values from any source.  A noise
    /// map is often used as a terrain height map or a grayscale texture.
    ///
    /// The size (width and height) of the noise map can be specified during
    /// object construction or at any other time.
    /// 
    /// All of the values outside of the noise map are assumed to have a
    /// common value known as the border value.
    ///
    /// To set the border value, modify the BorderValue property.
    /// </remarks>
    public class NoiseSphere : Map<float>
    {
        public override int UsedMemory
        {
            get
            {
                return values.Length * sizeof(float);
            }
        }

        public float Min
        {
            private set;
            get;
        }

        public float Max
        {
            private set;
            get;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        public NoiseSphere() { }

        /// <summary>
        /// Constructor.
        /// </summary>
        public NoiseSphere(int width, int height)
            : base(width, height)
        {

        }

        /// <summary>
        /// Constructor.
        /// </summary>
        public NoiseSphere(NoiseMap other)
            : base(other)
        {

        }

        public new float this[int x, int y]
        {
            get
            {
                return GetValue(x, y);
            }
            set
            {
                SetValue(x, y, value);
            }
        }

        public new float GetValue(int x, int y)
        {
            if (values != null)
            {
                int w = Width;
                int h = Height;

                if (x < 0)      x = w + x;
                if (x > w - 1)  x = x - w + 1;
                if (y < 0)      y = h + y;
                if (y > h - 1)  y = y - h + 1;

                return values[GetIndex(x, y)];
            }

            return BorderValue;
        }

        public new void SetValue(int x, int y, float value)
        {
            if (values != null)
            {
                int w = Width;
                int h = Height;

                if (x < 0)          x = w + x;
                if (x > w - 1)      x = x - w + 1;
                if (y < 0)          y = h + y;
                if (y > h - 1)      y = y - h + 1;

                if (value >= Max)   Max = value;
                if (value <= Min)   Min = value;

                values[GetIndex(x, y)] = value;
            }
        }

        public Vector3 GetNormal(int x, int y, int H = 8)
        {
            var u1 = GetValue(x - 1, y);
            var u2 = GetValue(x + 1, y);
            var v1 = GetValue(x, y - 1);
            var v2 = GetValue(x, y + 1);

            //var dx = (u1 - u2 + 1f) * 0.5f;
            //var dy = (v1 - v2 + 1f) * 0.5f;
            //var result = new Vector3(dx, dy, 1f);

            // Calculate derivatives
            var dx = (u1 - u2) * 0.5f;
            var dy = (v1 - v2) * 0.5f;
            var normalX = new Vector3(H * dx, 0, 1);
            var normalY = new Vector3(0, H * dy, 1);

            // Get normal vector
            var normalVector = normalX + normalY;
            normalVector.Normalize();

            // Get color vector
            var colorVector = Vector3.zero;
            colorVector.x = (normalVector.x + 1) / 2;
            colorVector.y = (normalVector.y + 1) / 2;
            colorVector.z = (normalVector.z + 1) / 2;

            return colorVector;
        }

        public float GetSteepness(int x, int y, int H = 8)
        {
            // Compute the differentials by stepping over 1 in both directions.
            // TODO: Ensure these are inside the heightmap before sampling.
            float dx = GetValue(x + 1, y) - GetValue(x - 1, y);
            float dy = GetValue(x, y + 1) - GetValue(x, y - 1);

            // The "steepness" is the magnitude of the gradient vector
            // For a faster but not as accurate computation, you can just use abs(dx) + abs(dy)         
            return 0.5f * H * Mathf.Sqrt(dx * dx + dy * dy);
        }

        public float GetShadow(int x, int y, int radius = 5, int H = 8)
        {
            var v = GetValue(x, y);
            var delta = 0f;
            for (int i = 1; i < radius; i++)
            {
                var other = GetValue(x - i, y - i);
                var diff = other - v;
                delta += diff / (1f + i);
            }
            return Mathf.Min(0.2f, H * delta);
        }

        public float GetShade(int x, int y)
        {
            var v = GetValue(x, y);

            var x0 = GetValue(x - 1, y);
            var x1 = GetValue(x - 2, y);
            var y0 = GetValue(x, y + 1);
            var y1 = GetValue(x, y + 2);

            var sum = v + x0 + x1 + y0 + y1;
            var mean = sum * 0.2f;
            var std =
                (v - mean) * (v - mean)
                + (x0 - mean) * (x0 - mean)
                + (x1 - mean) * (x1 - mean)
                + (y0 - mean) * (y0 - mean)
                + (y1 - mean) * (y1 - mean);
            std *= 0.2f;
            std = Mathf.Sqrt(std);
            var difference = v - mean;

            if (std == 0)
            {
                return difference;
            }

            var result = difference / std;
            //result = 0.5f + Mathf.Clamp(0.5f * result, -0.5f, 0.5f);
            return result;
        }

        public float GetAspect(int x, int y)
        {
            var v = GetValue(x, y);

            var x0 = GetValue(x - 1, y);
            var x1 = GetValue(x - 2, y);
            var y0 = GetValue(x, y + 1);
            var y1 = GetValue(x, y + 2);
            var xy = GetValue(x - 1, y + 1);

            var result = 5f * v - x0 - x1 - y0 - y1 - xy;
            result /= (Max - Min);
            return result;
        }

        public int[] GetHistogram(int size = 256)
        {
            int[] histogram = new int[size];
            float delta = Max - Min;
            if (delta == 0)
                return histogram;

            int n = size - 1;
            for (int x = 0; x < Width * Height; x++)
            {
                var val = (values[x] - Min) / delta;
                val = Mathf.Clamp01(val);
                int index = (int)(val * n);
                index = Mathf.Clamp(index, 0, n);
                histogram[index]++;
            }

            return histogram;
        }

        public float SetZeroLevel(float fraction, int resolution = 256)
        {
            var histogram = GetHistogram(resolution);
            var zero = Min;

            if (fraction < 1f / (resolution-1))
            {
                return zero; // WTF?
            }

            int i, cutoff, soFar = 0;
            cutoff = (int)(fraction * Width * Height);
            for (i = 0; i < resolution; i++)
            {
                soFar += histogram[i];
                if (soFar >= cutoff)
                {
                    zero = ((float)i / (float)resolution);
                    return zero;
                }
            }

            return zero;
        }

        /// <summary>
        /// Create a new NoiseMap from the given source NoiseMap using bilinear filtering.
        /// 
        /// When the sample is outside the source BorderValue is used by default. If <see cref="clamp"/>/>
        /// is set clamping is used instead.
        /// </summary>
        /// <param name="src">The source NoiseMap</param>
        /// <param name="width">Width of the new NoiseMap</param>
        /// <param name="height">Height of the new NoiseMap</param>
        /// <param name="clamp">Use clamping when the sample is outside the source NoiseMap</param>
        /// <returns>The new NoiseMap</returns>
        public static NoiseSphere BilinearFilter(NoiseMap src, int width, int height, bool clamp = false)
        {
            var dest = new NoiseSphere(width, height);

            float xratio = (float)src.Width / dest.Width;
            float yratio = (float)src.Height / dest.Height;

            Parallel.For(0, dest.Height, y =>
            {
                for (int x = 0; x < dest.Width; ++x)
                {
                    float u = (x + 0.5f) * xratio - 0.5f;
                    float v = (y + 0.5f) * yratio - 0.5f;

                    int x0 = NoiseMath.FastFloor(u);
                    int y0 = NoiseMath.FastFloor(v);
                    int x1 = x0 + 1;
                    int y1 = y0 + 1;

                    float xf = u - x0;
                    float yf = v - y0;

                    if (clamp)
                    {
                        x0 = NoiseMath.Clamp(x0, 0, src.Width - 1);
                        x1 = NoiseMath.Clamp(x1, 0, src.Width - 1);
                        y0 = NoiseMath.Clamp(y0, 0, src.Height - 1);
                        y1 = NoiseMath.Clamp(y1, 0, src.Height - 1);
                    }

                    float c00 = src.GetValue(x0, y0);
                    float c01 = src.GetValue(x0, y1);
                    float c10 = src.GetValue(x1, y0);
                    float c11 = src.GetValue(x1, y1);

                    float val = NoiseMath.Bilinear(xf, yf, c00, c01, c10, c11);

                    dest.SetValue(x, y, val);
                }
            });

            return dest;
        }
    }
}
